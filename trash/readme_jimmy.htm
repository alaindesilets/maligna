<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">

<HTML><HEAD><meta http-equiv="content-type" content="text/html; charset=UTF-8"><TITLE>Read Me</TITLE></HEAD><BODY>

<H1>mALIGNa</H1>

<h3>Version @project.fullversion@, Date @build.date@</h3>
<hr>

<H2>Table of Contents</H2>
<OL>
	<LI><A href="#introduction">Introduction</A></LI>
	<LI><A href="#requirements">Requirements</A></LI>
	<LI><A href="#running">Running</A></LI>
	<LI><A href="#formats">Formats</A></LI>
	<LI><A href="#algorithms">Algorithms</A></LI>
	<LI><A href="#sources">Sources</A></LI>
	<LI><A href="#tools">Tools</A></LI>
</OL>

<HR>

<H2><A name="introduction">1. Introduction</A></H2>
<P>mALIGNa is a program for aligning documents on the sentence level. It contains implementations of a few groups of alignment algorithms - algorithms based exclusively on the sentence length (Gale and Church, Brown), algorithms based on the connections between words (Moore's algorithm), as well as any variation and intersection of these algorithms. The aim of alignment is to obtain a bilingual corpus. It can be used for creating translation memories, translation by analogy, modelling probabilistic dictionaries and other applications.</P>

<H2><A name="requirements">2. Requirements</A></H2>
<P>JVM 1.6 is required to run the program. To build the program both JDK 1.6 and Ant are required. Theoretically, the program is platform independent (like Java), it was tested on Linux and Windows.</P>

<H2><A name="running">3. Running</A></H2>
<P>Aligning documents consists of several stages, which may be performed in different ways. Therefore, the text interface of the program is divided into several independent commands. A common feature of the commands is that they read from standard input and write the results to standard output, always using the native format .al. Therefore these programs act as filters and may be combined in a pipe using |. Below is a brief description of each command, you can get more information about their exact parameters using the option --help. At the end, there is a complete example of text alignment using several commands connected in a pipeline.</P>
<P>

<H3><A name="parsecommand">3.1 The 'parse' command</A></H3>
<P>The parse option is used to convert an external format to the native format .al. It also allows you to combine several documents into one, by giving a list of files as arguments. It accepts input files as aguments and writes the result to standard output. This can only occur at the beginning of the pipeline.</P>

<H3><A name="formatcommand">3.2 The 'format' command</A></H3>
<P>The 'format' option is used to convert the native format .al to an external format. It reads data from standard input and writes the result to the files given as arguments. This can only occur at the end of the pipeline.</P>

<H3><A name="aligncommand">3.3 The 'align' command</A></H3>
<P>Alignment commands. Segments of each of the input alignments are aligned independently, thanks to which alignments can be performed at different levels of accuracy (document, paragraph, sentence), performing consecutive alignments, and then dividing the results into smaller and smaller segments. Filter; may be used at any point of the pipeline.</P>

<H3><A name="modifycommand">3.4 The 'modify' command</A></H3>
<P>This option performs modifications on every alignment, replacing source and target lists of segments with other lists of segments, in addition both the size of the segments and their contents may be changed (e.g. connect segments in one, divide them into more segments or remove unnecessary whitespace). Filter; may be used at any point of the pipeline.</P>

<H3><A name="selectcommand">3.5 The 'select' command</A></H3>
<P>On the basis of certain criteria, chooses from the input lists of alignments only a few and writes them to output. Eg. using this you can choose only the most probable alignments or only 1 - 1 alignments. Filter; may be used at any point of the pipeline.</P>

<H3><A name="comparecommand">3.6 The 'compare' command</A></H3>
<P>This is used for comparing two files of alignments with each other, provided as arguments, returning the degree of their similarity and the differences occurring. Used for test targets.</P>

<H3><A name="testcommand">3.7 The 'test' command</A></H3>
<P>Runs the program's automatic tests.</P>

<H3><A name="runningexample">3.6 Examples of running</A></H3>
<P>Below I have given examples of pipelines of commands that that should be used to join together two documents in .txt files, and also write the results as two .txt files, also the input documents should contain the same number of sentences, one per line, and sentences of corresponding numbers should be mutual translations. The commands given below will do everything, however it is worth remembering that sometimes it's better to preserve the intermediate results of the operations of each command in temporary files instead of redirecting them directly to the next command. The following command writes the string in one line; it has been split into several lines in order to enhance readability. They are being carried out in the main directory of the project. Ready to run scripts containing these commands can be found in the directory examples/scripts,</P>
<P><CODE>
bin/maligna parse -c txt example/txt/poznan-pl.txt example/txt/poznan-de.txt | <BR>
bin/maligna modify -c sentencesplit | <BR>
bin/maligna modify -c trim | <BR>
bin/maligna align -c viterbi -a poisson -n word -s iterband | <BR>
bin/maligna select -c onetoone | <BR> 
bin/maligna format -c txt poznan-pl-align.txt poznan-de-align.txt
</CODE></P>
<P>Another case worth attention is alignment using Moore's algorithm, which requires a properly aligned corpus to build a translation model. To do this you must perform several commands.</P>
<P><CODE>
bin/maligna parse -c txt example/txt/poznan-pl.txt example/txt/poznan-de.txt | <BR> 
bin/maligna modify -c sentencesplit | <BR>
bin/maligna modify -c trim &gt; <BR>
poznan-split.al
</CODE></P>
<P><CODE>
cat poznan-split.al | <BR>
bin/maligna align -c viterbi -a poisson -n word -s iterband | <BR> 
bin/maligna select -c onetoone | <BR>
bin/maligna select -c fraction -f 0.85 &gt; <BR>
poznan-align-length.al
</CODE></P>
<P><CODE>
cat poznan-split.al | <BR>
bin/maligna align -c viterbi -a poisson-translation -n word -s iterband -t poznan-align-length.al &gt; <BR>
poznan-align.al
</CODE></P>

<H2><A name="formats">4. Formats</A></H2>
<P>Most commands expect input and output in the native format .al. To use a different format, you must parse the input (using the parse command). To get the result in another format, you need to format it (using the format command).</P>

<H3><A name="formatal">4.1 The .al format</A></H3>
<P>This is the native format for files of alignment lists. Contains all necessary information for alignment: lists of source and target segments and result (probability) of alignment.</P>

<H3><A name="formattmx">4.2 The .tmx format</A></H3>
<P>The standard format for translation memories, supported by many tools. Both an input and output format. For the full specification, see: <A href="http://www.lisa.org/standards/tmx/tmx.html">http://www.lisa.org/standards/tmx/tmx.html</A>.</P>

<H3><A name="formattxt">4.3 The .txt format</A></H3>
<P>Plain text, in the form of two files in two languages. On input the whole file is treated as one segment. On output, successive lines of files correspond by alignment and are mutual translations (their quantity is equal).</P>

<H3><A name="formatpresentation">4.4 The presentation format</A></H3>
<P>An output format which allows the presentation of an alignment in a human readable manner. It is written to a text file in two columns.</P>

<H2><A name="algorithms">5. Algorithms</A></H2>
<P>In the program a few alignment algorithms were applied, and thanks to the flexibility of the code it is possible to modify them and join them together.</P>

<H3><A name="algorithmgc">5.1 Gale and Church algorithm</A></H3>
<P>This is a fast bilingual text alignment algorithm. The algorithm counts the probability of each possible alignment, which depends on the length of sentences in each language, the length of the whole texts in each language (with no loss of accuracy averaged to 1:1) and some constants. Next it finds alignments for the whole text, maximalising the total probability of alignment. Details can be found in the Gale and Church article, referenced in the sources.</P>

<H3><A name="algorithmmoore">5.1 Moore's algorithm</A></H3>
<P>This is a modern algorithm based not only on the length of sentences but also on the relationships between words. The first phase of operation of this algorithm is alignment based on length (similarly to the Gale and Church algorithm; moreover, it can be used as the first phase of that algorithm). Next, from this alignment only 1 - 1 alignments are selected, and from them only the best part (e.g. 80%). In this manner a relatively well aligned corpus is yielded. Later a translation model (IBM Model 1) and unigram language models are built based on this corpus. In the final alignment not only is the probability of alignment of sentences of determined length taken into consideration, but also the probability of the translation of the source sentence to the target sentence (counted on the basis of the translation model and the language models, in the standard way). Details can be found in the Moore article, referenced in the sources.</P>

<H2><A name="sources">6. Sources</A></H2>
<P>
</P><OL>
<LI>A Program for Aligning Sentences in Bilingual Corpora, William A. Gale, Kenneth Ward Church</LI>
<LI>Fast and Accurate Sentence Alignment of Bilingual Corpora, Robert C. Moore</LI>
</OL>
<P>

<H2><A name="tools">7. Tools</A></H2>
<P>I wrote this program using the Eclipse IDE. For the automation of various tasks, I used the program Ant.</P>

<HR>

<P>I wrote this program as part of my studies in Machine Translation, and later I expanded it as part of a master's thesis.  Happy aligning!</P>
<P>&nbsp;&nbsp; -- Jarek Lipski</P>


</BODY></HTML>
 	  	 
